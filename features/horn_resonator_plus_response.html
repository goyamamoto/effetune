<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HornResonatorPlus Frequency Response</title>
<link rel="stylesheet" href="../effetune.css">
<link rel="icon" href="../images/favicon.ico" type="image/x-icon">
<style>
 body { font-family: Arial, sans-serif; background:#1a1a1a; color:#eee; }
 .controls { margin:10px; }
 canvas { background:#000; }
 label { margin-right:1em; }
 .back-button {
  position: absolute;
  top: 20px;
  left: 20px;
  padding: 8px 16px;
  background-color: #2d2d2d;
  border: 1px solid #3d3d3d;
  color: #ffffff;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  align-items: center;
  font-size: 14px;
  z-index: 100;
 }
 .back-button:hover { background-color: #3d3d3d; }
 .back-button svg { margin-right: 6px; width: 16px; height: 16px; }
</style>
</head>
<body>
<button id="back-button" class="back-button">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M19 12H5M12 19l-7-7 7-7"/>
  </svg>
  Back to EffeTune
</button>
<h1>HornResonatorPlus Frequency Response</h1>
<div class="controls">
  <label>Brightness A: <input id="b1" type="range" min="0" max="1" step="0.01" value="0"></label>
  <label>Brightness B: <input id="b2" type="range" min="0" max="1" step="0.01" value="1"></label>
  <button id="update">Update</button>
</div>
<canvas id="graph" width="800" height="400"></canvas>
<script src="../plugins/plugin-base.js"></script>
<script src="../plugins/resonator/horn_resonator_plus.js"></script>
<script type="module">
import FFT from './measurement/audio-utils/fft.js';

const plugin = new window.HornResonatorPlusPlugin();

function computeResponse(brightness) {
  plugin.setParameters({ bl: brightness });
  const sr = 48000;
  const chs = 1;
  const bs = 128;
  const ctx = {};
  const params = { ...plugin.getParameters(), sampleRate: sr, channelCount: chs, blockSize: bs };
  const total = 8192;
  const impulse = new Float32Array(bs);
  const response = new Float32Array(total);
  let offset = 0;
  for (let i = 0; i < total; i += bs) {
    impulse.fill(0);
    if (i === 0) impulse[0] = 1;
    plugin.executeProcessor(ctx, impulse, params, 0);
    response.set(impulse, offset);
    offset += bs;
  }
  const fftSize = 16384;
  const fft = new FFT(fftSize);
  const real = new Float32Array(fftSize);
  const imag = new Float32Array(fftSize);
  real.set(response, 0);
  fft.transform(real, imag, real, imag);
  const half = fftSize / 2;
  const result = [];
  for (let k = 0; k < half; k++) {
    const freq = sr * k / fftSize;
    if (freq < 20 || freq > 20000) continue;
    const mag = Math.sqrt(real[k] * real[k] + imag[k] * imag[k]);
    const db = 20 * Math.log10(mag + 1e-12);
    result.push([freq, db]);
  }
  return result;
}

function draw() {
  const b1 = parseFloat(document.getElementById('b1').value);
  const b2 = parseFloat(document.getElementById('b2').value);
  const resp1 = computeResponse(b1);
  const resp2 = computeResponse(b2);
  const canvas = document.getElementById('graph');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  const pad = {left:50,right:20,top:20,bottom:30};
  const minF = 20, maxF = 20000;
  const minDb = -40, maxDb = 20;
  const w = canvas.width - pad.left - pad.right;
  const h = canvas.height - pad.top - pad.bottom;
  const scaleX = f => pad.left + w * (Math.log10(f) - Math.log10(minF)) / (Math.log10(maxF) - Math.log10(minF));
  const scaleY = d => pad.top + h * (maxDb - d) / (maxDb - minDb);
  ctx.strokeStyle = '#444';
  for(let f=20; f<=20000; f*=10){
    const x = scaleX(f);
    ctx.beginPath(); ctx.moveTo(x,pad.top); ctx.lineTo(x,canvas.height-pad.bottom); ctx.stroke();
    ctx.fillStyle='#888'; ctx.font='10px Arial'; ctx.textAlign='center';
    ctx.fillText(f>=1000?(f/1000+'k'):f, x, canvas.height-5);
  }
  for(let d=minDb; d<=maxDb; d+=10){
    const y = scaleY(d);
    ctx.beginPath(); ctx.moveTo(pad.left,y); ctx.lineTo(canvas.width-pad.right,y); ctx.stroke();
    ctx.fillStyle='#888'; ctx.textAlign='right'; ctx.fillText(d+'dB', pad.left-5, y+3);
  }
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#ff6060';
  ctx.beginPath();
  resp1.forEach(([f,d],i)=>{ const x=scaleX(f), y=scaleY(d); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
  ctx.stroke();
  ctx.strokeStyle = '#60ff60';
  ctx.beginPath();
  resp2.forEach(([f,d],i)=>{ const x=scaleX(f), y=scaleY(d); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
  ctx.stroke();
}

document.getElementById('update').addEventListener('click', draw);
draw();

const backButton = document.getElementById('back-button');
backButton.addEventListener('click', () => {
  if (window.electronAPI) {
    window.electronAPI.navigateToMain()
      .catch(err => console.error('Error navigating to main page:', err));
  } else {
    window.location.href = '../effetune.html';
  }
});

window.addEventListener('load', () => {
  if (window.electronAPI) {
    window.electronAPI.hideApplicationMenu().catch(err => {
      console.error('Error hiding application menu:', err);
    });
  }
});

window.addEventListener('beforeunload', () => {
  if (window.electronAPI) {
    window.electronAPI.restoreDefaultMenu().catch(err => {
      console.error('Error restoring default menu:', err);
    });
  }
});
</script>
</body>
</html>
